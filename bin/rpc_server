#!/usr/bin/env ruby

require 'thor'
require 'protobuf/version'
require 'protobuf/common/logger'
require 'protobuf/rpc/server'
require 'protobuf/rpc/servers/evented_runner'
require 'protobuf/rpc/servers/socket_runner'
require 'protobuf/rpc/servers/zmq_runner'

class RpcServer < ::Thor
  include ::Thor::Actions

  attr_accessor :runner, :start_aborted

  default_task :start

  desc 'start APP_FILE', 'Run the RPC server in the given mode, preloading the given APP_FILE. This is the default task.'

  option :env,                    :type => :string, :default => (ENV['RPC_SERVER_ENV'] || 'development'), :aliases => %w(-e), :desc => 'Environment to run the server (i.e. RAILS_ENV).'
  option :host,                   :type => :string, :default => '127.0.0.1', :aliases => %w(-e), :desc => 'Host to bind.'
  option :port,                   :type => :numeric, :default => 9595, :aliases => %w(-p), :desc => 'Port to bind.'
  option :backlog,                :type => :numeric, :default => 100, :aliases => %w(-b), :desc => 'Backlog for listening socket when using Socket Server.'
  option :threshold,              :type => :numeric, :default => 100, :aliases => %w(-t), :desc => 'Multi-threaded Socket Server cleanup threshold.'
  option :log,                    :type => :string, :default => File.expand_path('./protobuf.log'), :aliases => %w(-l), :desc => 'Log file or device.'
  option :level,                  :type => :numeric, :default => ::Logger::INFO, :aliases => %w(-v), :desc => 'Log level to use, 0-5 (see http://www.ruby-doc.org/stdlib/libdoc/logger/rdoc/)'
  option :client_type,            :type => :boolean, :desc => 'Client Type to use (Socket or Zmq).'
  option :server_type,            :type => :boolean, :desc => 'Server Type to use (Socket or Zmq).'
  option :client_socket,          :type => :boolean, :aliases => %w(-c), :desc => 'Raw Socket Mode for client connections.'
  option :socket,                 :type => :boolean, :aliases => %w(-s), :desc => 'Raw Socket Server Mode.'
  option :zmq,                    :type => :boolean, :aliases => %w(-z), :desc => 'ZeroMQ Socket Mode for client and server connections (they must be used together).'
  option :debug,                  :type => :boolean, :default => false, :aliases => %w(-d), :desc => 'Debug Mode. Override log level to DEBUG.'
  option :pre_cache_definitions,  :type => :boolean, :default => false, :desc => 'Enable/Disable Message class pre-caching.'
  option :gc_pause_request,       :type => :boolean, :default => false, :desc => 'Enable/Disable GC pause during request.'
  option :gc_pause_serialization, :type => :boolean, :default => false, :desc => 'Enable/Disable GC pause during serialization.'

  def start(app_file)
    say 'start to configure', :yellow
    @start_aborted = false
    require 'protobuf'

    configure_traps
    configure_runner_mode
    configure_gc
    configure_logger

    unless  @start_aborted
      say 'start was not aborted', :yellow
      require_application!(app_file)
      pre_cache_application_protos! if options.pre_cache_definitions?
      configure_process_name(app_file)
      start_server!
    else
      say 'start was aborted', :yellow
    end

  rescue => e
    msg = "ERROR: RPC Server failed to start: (#{e.class.name}) #{e.message}"
    say msg, :red
    $stderr.puts *(e.backtrace)
    ::Protobuf::Logger.error { msg }
    ::Protobuf::Logger.error { e.backtrace.join("\n") }
    exit(1)
  end

  desc 'version', 'Print ruby and protoc versions and exit.'
  def version
    $stdout.puts "Ruby Protobuf v#{::Protobuf::VERSION} (Google protoc v#{::Protobuf::PROTOC_VERSION})"
    exit(0)
  end

  no_tasks do

    # TODO need to figure out a better solution here
    # dynamic const assignment is a no-go
    def configure_gc
      say 'configuring gc', :yellow
      #::Protobuf::Rpc::GC_PAUSE_REQUEST = options.gc_pause_request?
      # If we pause during request we don't need to pause in serialization
      #::Protobuf::Rpc::GC_PAUSE_SERIALIZATION = (!options.gc_pause_request? && options.gc_pause_serialization?)
    end

    def configure_logger
      say 'configuring logger', :yellow
      ::Protobuf::Logger.configure({ :file => options.log,
                                     :level => options.debug? ? ::Logger::DEBUG : options.level })

      # Output the server opts
      ::Protobuf::Logger.debug { 'Debugging options:' }
      ::Protobuf::Logger.debug { options.inspect }
    end

    def configure_process_name(app_file)
      say 'configuring process name', :yellow
      $0 = "rpc_server #{options.host}:#{options.port} #{app_file}"
    end

    # Used to ensure we set the PB_CLIENT_TYPE and PB_SERVER_TYPE to the same thing
    # if one of them is set to Zmq
    def configure_runner_mode
      say 'configuring runner mode', :yellow
      if ENV['PB_CLIENT_TYPE'] =~ /zmq/i
        # make server and client types the same if we're using Zmq
        # ENV['PB_SERVER_TYPE'] = ENV['PB_CLIENT_TYPE']
        @runner = ::Protobuf::Rpc::ZmqRunner
      elsif ENV['PB_SERVER_TYPE'] =~ /zmq/i
        # make server and client types the same if we're using Zmq
        # ENV['PB_CLIENT_TYPE'] = ENV['PB_SERVER_TYPE']
        @runner = ::Protobuf::Rpc::ZmqRunner
      elsif ENV['PB_SERVER_TYPE'] =~ /socket/i
        @runner = ::Protobuf::Rpc::SocketRunner
      else
        @runner = ::Protobuf::Rpc::EventedRunner
      end
    end

    def configure_traps
      say 'configuring traps', :yellow
      trap_block = proc {
        ::Protobuf::Logger.info { 'RPC Server shutting down...' }
        @start_aborted = true
        @runner.stop
        ::Protobuf::Logger.info { 'Shutdown complete' }
      }

      say 'registering INT', :blue
      trap(:INT, &trap_block)
      say 'registering QUIT', :blue
      trap(:QUIT, &trap_block)
      say 'registering TERM', :blue
      trap(:TERM, &trap_block)
    end

    def pre_cache_application_protos!
      say 'pre-caching app protos', :yellow
      ::Protobuf::Message.pre_cache_class_definitions
    end

    def require_application!(app_file)
      say 'requiring app file', :yellow
      require app_file
    rescue LoadError => e
      say "Failed to load application file #{app_file}: #{e.message}", :red
      puts *(e.backtrace) if options.debug?
      exit(1)
    end

    def runner_name
      case @runner
      when ::Protobuf::Rpc::ZmqRunner then "Zmq"
      when ::Protobuf::Rpc::SocketRunner then "Socket"
      else "Evented"
      end
    end

    def start_server!
      say 'starting server', :yellow
      @runner.run(options.dup) do
        Protobuf::Logger.info { "pid #{::Process.pid} -- #{runner_name} RPC Server listening at #{options.host}:#{options.port} in #{options.env}" }
      end
    end

  end

end

::RpcServer.start(ARGV)
